# 常用排序算法



## 选择排序

算法思想：  

每一趟从待排序的数据元素中选择一个最小（或者最大）的元素，放在前边排好序的元素后边。直到所有元素全部排好序。  

时间复杂度：  

最坏情况：  

稳定性：  



## 插入排序

算法思想：  

从未排序的序列中拿出一个，遍历已经排好序的序列找到合适的位置，将未排序的元素插入到已排好序的序列的合适位置。  

时间复杂度：  

最坏情况：  

稳定性：  



## 冒泡排序

算法思想： 

每一趟只对比相邻的两个元素，如果不符合排序条件，就交换这两个元素的位置。直到拍好序列。  

时间复杂度：  

最坏情况：  

稳定性：  



## 桶排序

算法思想：   

时间复杂度：  

最坏情况：  

稳定性：  



## 快速排序

算法思想：   

时间复杂度：  

最坏情况：  

稳定性：  



## 归并排序

算法思想：   

时间复杂度：  

最坏情况：  

稳定性：  



## 堆排序

算法思想：   

"小顶堆数据结构"：把未排序的数组看成是二叉树的数组存储结构，父节点小于左右孩子。  
因此堆排序算法可分为：建堆、调整以及输出三个阶段。
- 建堆： 调整元素位置使其满足"小顶堆"结构；
- 调整： 将堆顶元素(最小元素)移动到最末端，然后调整前边的元素位置，使其重新满足“小顶堆”结构；
- 输出： 将上一步放在最末端的元素输出，并重复“建堆、调整、输出“步骤。  

时间复杂度：  

最坏情况：  

稳定性：  





## 总结



| 算法     | 平均时间复杂度 | 最坏情况下时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | -------------- | -------------------- | ---------- | ------ |
| 选择排序 |                |                      |            |        |
| 插入排序 |                |                      |            |        |
| 冒泡排序 |                |                      |            |        |
| 桶排序 |                |                      |            |        |
| 快速排序 |                |                      |            |        |
| 归并排序 |                |                      |            |        |
| 堆 排序 |                |                      |            |        |

