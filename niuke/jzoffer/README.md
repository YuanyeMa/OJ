牛客网，《剑指offer》刷题记录。

# 01 - 二维数组中的查找

题目描述：
	在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 
	
解题思路：
	矩阵是有序的，对于行，从左往右下标变大，元素值递增；对于列从上往下，列下标变大，元素值递增；
	因此可以从矩阵的右上角开始搜索，当target元素比当前元素大时，行索引+1往下方搜索；否则列索引-1往左边搜索。
	
# 02 - [替换空格](./02-replaceSpace.cpp) 

题目描述：
	请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
	
解题思路：
	从后往前移动，两个指针，一个指向替换空格后的字符串的尾部（pw），另一个指向替换前字符串的尾部(pr)。如果遇到空格就在pw处写入替换的字符，否则就将pr处的字符赋值给pw。


# 03 - [从尾到头打印连表](./03-printListFromTailToHead.cpp) 

题目描述：
	输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
解题思路：
	此题和使用递归逆转单链表类似，但是更简单一些，可以设置一个全局或者似有的vector<int>容器，递归返回的时候，将节点的value域push_back给vector，最后返回构造的vector即可。

# 04 -  重建二叉树

题目描述：
	输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
	
解题思路：
	先根序的第一个元素一定为根元素，中根序中根左边的元素一定在左子树，右边的元素一定在右子树。可以通过递归进行树的重建。
	目前还没写出来。

# 05 - [用两个栈来实现一个队列](./05-stack-make-queue.cpp)

题目描述：  
	完成队列的Push和Pop操作。 队列中的元素为int类型。
解题思路：
	两个栈，一个作为调整元素顺序的buffer使用。
	入队时：先将stack1的元素都pop到stack2中去；然后将新元素push到stack1；再将stack2中的pop回stack1;
	出队时：直接从stack1 pop一个元素。
	
	
